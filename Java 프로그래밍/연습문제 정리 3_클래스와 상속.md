```
  1. 추상화에 관한 정확한 설명은 무엇인가?
              a. 비밀스러운 데이터의 직접 접근을 막는 것
              b. 데이터와 메소드를 하나의 틀에 담는 것
              c. 기존 대상을 재사용하되 새로운 특성을 추가하여 새로 만드는 것
              d. 본질적이고 전형적인 부분만 간추려 대상을 표현하는 것
    d
      해설 추상화는 복잡한 실체를 간단히 표현하는 것을 말한다. 
           b는 캡슐화에 관한 설명이며 
           c는 클래스의 상속과 관련이 있다. 
```

```
  2. 클래스 정의에 포함될 수 없는 것은?
            a. 인스턴스 필드 
            b. 정적 필드
            c. 전역변수 
            d. 인스턴스 메소드
    c
      해설 Java 프로그램에서 전역변수는 존재하지 않는다. 
           인스턴스 필드, 인스턴스 변수, 멤버 필드, 멤버 변수, 정적이 아닌 필드, non-static 필드는 모두 같은 의미의 용어이다. 
           인스턴스 메소드, 멤버 메소드, 정적이 아닌 메소드, non-static 메소드는 모두 같은 의미이다. 
           인스턴스 필드는 개별 객체가 배타적으로 가지고 있는 필드를 말하며 인스턴스 메소드란 개별 객체가 배타적으로 수행시키는 메소드를 말한다.
```

```
  3. 다음 중 나머지 셋과 다른 의미를 가지는 용어는 무엇인가?
              a. 정적 메소드 
              b. static 메소드
              c. 클래스 메소드 
              d. 추상 메소드
    d
      해설 정적 메소드, static 메소드, 클래스 메소드는 모두 같은 의미의 용어이다. 
           마찬가지로 정적 필드, 정적 변수, static 필드, 클래스 변수는 모두 같은 의미의 용어이다. 
           정적인 필드는 자료형이 같은 객체들이 공유하는 필드를 말한다. 
           static 메소드는 개별 객체와 상관없이 클래스 이름을 통해 호출할 수 있는 메소드이다.
```

```
   4.  서브 클래스가 슈퍼 클래스를 상속받을 때 사용해야 하는 키워드는 무엇인가? 다중 상속이 가능한가?
    extends이며 단일 상속만 가능하다.
      해설 서브 클래스가 여러 개의 슈퍼 클래스를 상속받는 것을 다중 상속이라 하는데 클래스를 상속받을 때는 단일 상속만 가능하다.
```

```
  5. 톱레벨 클래스의 접근 제어자로 가능한 것은 무엇인가? 
    public과 생략
      해설 톱레벨 클래스는 public 클래스와 private 클래스가 될 수 없다. 
           클래스 접근 제어자로서 public과 private는 다른 클래스 내부에서 선언된 클래스에만 적용될 수 있다.
```

```
  6. 다음 네 가지 접근 제어자 가운데 두 번째로 넓은 사용범위를 제공하는 것은?
            a. public 
            b. 생략
            c. protected 
            d. private
    c
      해설 protected 필드나 메소드를 사용할 수 있는 범위는 같은 패키지와 서브 클래스이다. 
           예를 들어 A 유형의 객체 a가 protected 필드 p를 가지고 있다고 하면 a.p와 같은 표현을 같은 패키지나 서브 클래스에서만 사용할 수 있다는 것이다. 
           그 범위를 벗어난 임의의 클래스에서 사용한다면 컴파일 오류가 발생한다.
```

```
  7. 다음 문장에 관한 설명으로 잘못된 것이 있다면 모두 고르시오.
              Circle c 〓 new Circle(5);
                a. 참조형 변수가 선언되었다.
                b. 객체가 사용할 메모리 공간이 할당되었다.
                c. 변수 c에 메모리의 주소가 대입되었다.
                d. 생성자가 실행된다.
    모두 올바른 설명이다.
      해설 참조형 변수 c가 선언되었으며(Circle c), 메모리 공간이 할당되었고(new), 메모리의 주소가 변수 c에 대입되었으며(〓), 생성자가 실행되었다(Circle(5)).
```

```
  8. 다음 중 아래 메소드와 함께 오버로딩될 수 없는 것은?
                double compute(int x, int y)
                  a. int compute(int x, int y)
                  b. double compute(int x)
                  c. double compute(double x, double y)
                  d. double compute(int x, int y, int z)
    a
      해설 하나의 클래스에서 이름이 같은 메소드가 여러 개 존재할 때 메소드가 오버로딩되었다고 말한다. 
           오버로딩된 메소드들은 매개변수의 개수나 유형으로 구별될 수 있어야 한다. 
           a의 경우에는 리턴 타입이 다른데 이것은 구별되는 요소가 아니다.
```

> ![image](https://user-images.githubusercontent.com/17442343/171998440-9f2bceb7-f20b-47d2-ac36-91509bf636f6.png)

> ![image](https://user-images.githubusercontent.com/17442343/171998469-6197f9ec-705d-4940-936e-371f5520f706.png)

> ![image](https://user-images.githubusercontent.com/17442343/171998494-a105b9b1-a90b-441e-b120-3a1c14a9017b.png)







