```
  01. 자신이 사용하는 언어의 한계가 자신이 인지할 수 있는 한계임을 지적한 사람은 ?
    1) 괴델
    2) 러셀
    3) 힐베르트
    4) 비트겐슈타인
      비트겐슈타인은 '내 언어가 내 세계의 한계'라고 주장하였다.
  
  02. 프로그래밍 언어를 배워야 하는 이유로 보기 힘든 것은 ?
    1) 언어 사용자로서 언어를 자세히 배울 수 있게 해 준다.
    2) 문제 해결자로서 현명하게 언어를 선택하게 해 준다.
    3) 프로젝트 관리자로서 코드보안을 높일 수 있게 해 준다.
    4) 언어 설계자로서 적합한 언어 기능을 설계 할 수 있게 해준다.
      코드 보안은 중요한 주제이긴 하지만 프로그래밍 언어의 측면보다 네트워크 보안이나 시스템 보안 등 다른 주제가 더 많이 관련 되어 있다.
  
  03. 프로그래밍 언어가 지원하는 기능이 아닌 것은 ?
    1) 모듈화
    2) 실행 가능성
    3) 추상화
    4) 효율성
      효율성은 프로그래밍 언어가 직접 지원하는 특성이라기보다 프로그래밍 언어 구현이 지원하는 특성이다.
  
  04. 프로그래밍 언어의 일반적인 특성과 관련이 적은 것은 ?
    1) 가변적
    2) 구조적
    3) 기계적
    4) 함축적
      프로그래밍 언어 중 간결성을 지원하는 언어가 있기는 하지만 함축성은 프로그래밍 언어의 일반적인 특징이라고 보기 힘들다.
  
  05. 저급 언어부터 고급언어까지 언어의 스펙트럼을 결정하는 기준으로 가장 적합한 것은 ?
    1) 모듈화
    2) 실행 가능성
    3) 추상화
    4) 효율성
      프로그래밍 언어 스펙트럼은 추상화 수준에 의해 결정된다.
   
  06. 기계어가 고급언어가 아닌 이유로 가장 적합한 것은 ?
    1) 이해하기 힘든 기호를 사용하기 때문에
    2) 블록을 사용하지 않기 때문에
    3) 실행 속도가 느릴 수 있기 때문에
    4) 기계 종속적이기 때문에
      기계어는 기계 종속적이므로 기계어로 작성 된 프로그램은 다른 종류의 기계에서 사용 할 수 없다. 따라서 기계어는 고급언어로 간주하지 않는다.
  
  
  07. 원시연산과 사용자정의연산을 구별하는 기준은 ?
    1) 연산 의미가 복잡한지 여부
    2) 연산 구현이 어려운지 여부
    3) 언어가 미리 지원하는지 여부
    4) 사용자의 요구 사항을 만족시키는지 여부
      언어가 미리 지원하는 연산을 원시연산이라 부르고, 프로그래머에 의해 정의 된 연산을 사용자 정의 연산이라고 부른다.
  
  08. 함수와 프로시저를 구별하는 기준은 ?
    1) 결과 값 반환 여부
    2) 구현 본체의 크기
    3) 부대효과 발생 여부
    4) 인수를 필요로 하는지 여부
      함수와 프로시저를 구별하는 기준은 해당 서브프로그램이 결과 값을 반환하느냐 여부이다. 결과 값을 반환하면 함수이며 반환 값이 없으면 프로시저라고 부른다.
  
  09. 타입과 관련 된 언어의 특성이라고 할 수 없는 것은 ?
    1) 강타입 언어는 타입 오류를 모두 검출한다.
    2) 약타입 언어는 타입 오류를 허용할 수 있다.
    3) 강타입 언어에는 타입 선언문이 항상 존재한다.
    4) 무타입 언어에는 타입 개념이 없다.
      무타입 언어에도 타입 개념은 있다. 다만 어떤 식별자의 타입이 계속 바뀔 수 있는 것일 뿐이다. 강타입 언어에는 타입 선언문이 존재하지 않을 수 있지 않나 생각 할 수 있는데, 언어에는 항상 존재한다.
      다만 프로그램에 존재하지 않을 수 있을 뿐이다.
  
  10. 프로그래밍 언어를 배우는 방법으로 적절하지 않은 것은 ?
    1) 좋은 프로그램을 많이 읽어야 한다.
    2) 눈으로 따라가며 세부사항을 구별해야 한다.
    3) 프로그램 종류에 상관없이 많이 작성해 봐야 한다.
    4) 직접 실행해 보며 생각해 봐야 한다.
      프로그래밍 언어를 배울 때는 눈으로 따라가기보다 직접 작성하고 실행하며 따라가봐야 한다.
```

```
  01. 초기 컴퓨터였던 ENIAC과 EDVAC의 차이로 옳은 것은 ?
    1) ENIAC은 기계식, EDVAC은 전자식 컴퓨터
    2) ENIAC은 모클리와 에커트가, EDVAC은 폰 노이만이 설계
    3) ENIAC과 달리 EDVAC은 프로그램을 메모리에 저장했다.                                                  - 정답
    4) ENIAC과 달리 EDVAC은 기호 처리에 강했다.
      EDVAC은 내장프로그래밍 방식을 이용한 것으로 유명하다. ENIAC에서 프로그램을 변경하려면 배선을 바꾸어야만 했다.
  
  02. 운영체제 발전을 시간 순서대로 정리한 것은 ?
      가. 시분할 운영체제
      나. 일괄처리 운영체제
      다. DOS
      라. GUI 운영체제
    가 > 나 > 다 > 라
      일괄처리 운영체제와 시분할 운영체제는 초기서버에서 사용되는 방식으로, 멀티 프로그래밍이 가능하도록 일괄처리 운영체제를 개선한 것이 시분할 운영체제이다. 
      DOS는 PC 시대의 초기 운영체제이며 이후 GUI 운영체제로 발전한다.
  
  03. 초창기 시분할 운영체제보다 먼저 개발 된 언어는 ?
    1) BASIC
    2) C
    3) Fortran
    4) Python
      Fortran은 일괄처리 운영체제 시기부터 사용 된 언어이다.
  
  04. 클래스 개념이 없는 언어는 ?
    1) C
    2) Java
    3) Python
    4) Smalltalk
      C에는 클래스 개념이 존재하지 않는다.
  
  05. 최초의 함수형 언어로서 리스트 처리에 능한 언어는 ?
    1) Algol
    2) Cobol
    3) Fortran
    4) LISP
      LISP는 리스트 처리에 특화 된 최초의 함수형 언어로 유명하다.
  
  06. 다음 중 레코드 개념 뿐 아니라 고정소수점 수를 지원 했던 초기 프로그래밍 언어는 ?
    1) Algol
    2) Cobol
    3) Fortran
    4) LISP
      레코드 개념을 최초로 제안하고 고정소수점 수를 지원한 언어는 Cobol이다.
  
  07. 다음은 모두 직간접적으로 C로부터 유래된 언어이다. 이 중에서 Smalltalk와 가장 유사한 형태의 언어는 ?
    1) C++
    2) C#
    3) JAva
    4) Objective-C
      Objective-C는 Smalltalk와 유사한 형태의 구문으로 유명하다.
  
  08. CPU가 인출-해석-실행 주기를 수행할 때 CPU가 실행하는 명령어의 경로 흐름으로 가장 적합한 것은
    1) 메모리-BUS-CPU                                                                - 정답
    2) BUS-메모리-CPU
    3) CPU-BUS-메모리
    4) CPU-메모리-BUS
      메모리의 명령어는 인출 과정에서 BUS를 거쳐 CPU의 레지스터에 저장 된다. 
      실행 결과는 CPU에서 BUS를 거쳐 메모리에 저장 될 수 있지만 이는 자료의 흐름일 뿐 ㅇ명령어의 흐름이 아니다.
  
  09. 다음 중 하이브리드 구현과 가장 관련이 적은 것은 ?
    1) 가상기계
    2) 가상함수
    3) 클라우드 컴퓨팅
    4) 플랫폼 가상화
      하이브릳으 구현은 가상기계에서 수행 될 코드를 생성한다.
      따라서 가상화 및 클라우드 컴퓨팅과 관련이 깊다. 가상함수는 객체지향 언어 구현에 사용 된다.
  
  10. 다음 중 프로그래밍 언어 기능이 서로 간섭하지 않고 자유롭게 조합 될 수 있는 특성을 지칭하는 용어는 ?
    1) 유연성
    2) 이식성
    3) 일관성
    4) 직교성
      여러 기능이 독자적으로, 서로 간섭 없이 자유롭게 조합 될 수 있는 특성을 직교성이라고 한다.
```

```
  01. 다음 중 패러다임 전환의 사례로 적절하지 않은 것
    1) 그동안 천동설을 믿었는데 지동설이 사실인 것을 알았다.
    2) 저축하는 것이 좋은 줄 알았는데 이제 소비가 좋다고 한다.
    3) 큰 세력이 아니라 개인이 세상을 움직일 수 있는 것을 알았다.
    4) 밥을 못 먹을 줄 알았는데 결국 다 먹었다.
      4는 패러다임 전환이 아니라 예상 결과와 실제 결과가 다름을 나타낸다.
  
  02. 프로그래밍 패러다임이 변하는 이유로 적절하지 않은 것
    1) 프로그래머 비중이 점점 작아지고 있다.
    2) 컴퓨터 발전에 따라 프로그래밍 방식이 바뀌고 있다.
    3) 컴퓨터 사용 방식이 계ㅒ산에서 정보처리로 바뀌고 있다.
    4) 프로그램을 보는 관점이 효율성에서 가독성으로 바뀌고 있다.
      프로그래머의 비중이 작아지는 것은 패러다임 전환의 원인이 아니며, 실제로 사실이라고 보기도 힘들다.
  
  03. 다음 중 패러다임에 영향을 주는 요소를 모두 고른 것은 ?
      가. 계산 모델
      나. 응용 도메인
      다. 컴퓨터 속도
      라. 프로그램 구성 방식
        컴퓨터 속도는 프로그래밍 패러다임에 영향을 주는 요소로 볼 수 없다.
  
  04. 계산 모델에 따른 프로그래밍 언어 패러다임으로 볼 수 없는 것은 ?
    1) 논리 언어
    2) 명령형 언어
    3) 블록 구조 언어
    4) 함수형 언어
      블록 구조 언어는 프로그램 구성 방식에 따른 차이를 반영한 것이다.
  
  05. 초창기 BASIC은 절차형 언어라고 보지 않는 견해도 있따 그 이유는 ?
    1) 데이터 선언과 프로그램이 섞여 있었기 떄문에
    2) 명령어 대신 간단한 기호를 사용하였기 때문에
    3) 인수를 받는 서브루틴으로 개념이 희박했기 때문에                                                     - 정답
    4) 파일 개념이 없고 행 번호로 프로그램을 입력했기 때문에
      절차형 언어에서는 프로시저 개념이 중요하지만 초창기 BASIC에는 프로시저 개념이 충분히 발달하지 않았다.
  
  06. 다음 중 논란을 불러일으켜 결국 구조화 프로그래밍 개념을 발전시키게 된 프로그래밍 언어 기능은 ?
    1) common
    2) goto
    3) lambda
    4) switch
      E. W. 다익스트라의 편지로 촉발 된 goto 논란은 구조화 프로그래밍 발전을 가져온 것으로 유명하다.
  
  07. 다른 패러다임의 프로그래밍 언어에 대한 객체지향 프로그래밍 언어의 장점으로 가장 적합한 것은 ?
    1) 대화 방식의 프로그램 개발
    2) 소프트웨어의 재사용
    3) 안전한 소프트웨어의 작성
    4) 빠른 실행 속도
      클래스 및 상속 개념을 이용한 소프트웨어 재사용은 객체지향 프로그래밍 언어의 주요 장점이라고 할 수 있다.
  
  08. 현대 함수형 언어의 강점으로 볼 수 없는 것은 ?
    1) 고계함수를 통한 간략한 표현이 가능하다.
    2) 기호 계산에 용이하다.
    3) 문자열 처리에 강하다.
    4) 타입 추론 기능을 통한 프로그램 안전성을 지원한다.
      문자열 처리에 강한 언어는 SNOBOL, Perl 등 기타 패러다임 언어에서도 지원하는 것으로서, 함수형 언어의 강점이라고 보기 힘들다.
  
  09. 다음 중 논리 언어와 가장 관련이 적은 것은 ?
    1) 동일화(unification)
    2) 람다함수(lambda function)
    3) 술어 계산(predicate calculus)
    4) 연역적 데이터베이스(deductive database)
      논리 언어는 동일화를 통한 술어 패턴 매칭을 수행한다.
      또한 연역적 데이터베이스에 사용 되기도 했다.
      가장 관련이 적은 것은 람다함수이다. 람다함수는 함수형 언어와 관련이 깊다.
  
  10. 다음 중 GUI 환경과 더불어 객체지향 프로그래밍 패러다임에 가장 충실한 언어는 ?
    1) C++
    2) JAva
    3) Simula
    4) Smalltalk
      보기의 모든 언어는 객체지향 개념을 가지고 있다.
      이 중에서 클래스조차도 객체로 간주하고 있는 언어는 Smalltalk로 가장 객체지향 프로그래밍 패러다임에 충실하다고 볼 수 있따.
```

```
  01. 프로그래밍 언어의 형식적 정의가 필요한 이유로 알맞지 않은 것은 ?
    1) 프로그래밍 언어의 명확한 사용체계를 알려 준다.
    2) 언어 해석의 모호함을 없애 주다.
    3) 작성 된 프로그램의 동작 예측이 가능하다.
    4) 중의적인 표현을 할 수 있다.
      중의적인 표현은 언어 해석을 모호하게 만들고 프로그램의 동작 예측이 힘들어지기 때문에 형식적 정의를 통해 중의적인 표현을 할 수 없게 해야한다.
  
  02. 다음 프로그램을 구문론과 의미론의 관점으로 설명한 것으로 바른 것은 ?
      int start;
    1) 의미론: int와 start는 토큰
    2) 구문론: start는 정수형 변수
    3) 의미론: 사용 된 문자는 i, n, t, s, a, r, ;
    4) 구문론: 사용 된 규칙은 <변수선언> ::= <자료형> <변수> ;
      구문론 관점에서 사용 된 문자는  i, n, t, s, a, r, ; 이고, int와 start는 토큰이며, 사용 된 규칙은 <변수선언> ::= <자료형> <변수> ; 이다.
      의미론 관점에서 start는 정수형 변수이다.
  
  03. 구문론에 대한 설명으로 바르지 않은 것은 ?
    1) 프로그래밍 언어의 표면적인 구조를 정의
    2) 정의 된 구문을 통해 모든 정상적인 프로그램을 도출 가능
    3) 프로그램의 동작 결과를 예측 가능
    4) 작성 된 프로그ㅐㄹㅁ이 정의 된 구문에 맞는지 확인 가능
      프로그램의 동작 결과를 예측하는 것은 구문론이 아닌 의미론에서 가능 한 부분이다.
  
  04. 문맥 자유 문법에 대한 설명으로 바른 것은 ?
    1) 비단말 기호들, 시작 비단말 기호, 규칙들로만 구성 된다.
    2) 비단말 기호는 언어에서 직접 사용되는 표현이다.
    3) 시작 비단말 기호는 모든 정의 될 대상을 표현한다.
    4) 각 규칙은 하나의 비단말 기호를 구체적으로 정의한다.                                                             - 정답
      문맥 자유 문법의 구성은 비단말 기호들, 시작 비단말 기호, 규칙들 뿐만 아니라 단말기호들까지 포함한다.
      단말 기호는 언어에서 직접 사용되는 표현이고
      비단말 기호는 모든 정의 될 대상을 표현하며 시작 비단말 기호는 그 중 언어에서 독립적으로 사용 될 수 있는 단위를 표현한다.
  
  05. 문맥 자유 문법을 표현하는 방법이 아닌 것은 ?
    1) BNF
    2) EBNF
    3) 파스 트리
    4) 구문 도표
      파스트리는 구문 규칙을 이용하여 주어진 프로그램을 만들어 내는 과정을 트리 형태로 나타낸 것으로, 
      문맥 자유 문법을 표현하는 것이 아니라 활용하는 것이다.
  
  06. 각 기호에 대한 설명으로 바른 것은 ?
    1) <digit> : 단말 기호
    2) 0 : 비단말 기호
    3) | : 메타 기호
    4) { : 단말 기호
      <digit>은 비단말 기호,
      0은 단말 기호,
      |는 메타 기호이다.
      {는 BNF 표기법에서는 단말기호지만 EBNF 표기법에서는 메타 기호이다.
      
  07. BNF 표기법에는 해당하지 않아 EBNF와는 다르게 해석 되는 것은 ?
    1) <unsigned integer>
    2) ::=
    3) { <digit> }
    4) 0 | 1 | 2
      EBNF 표기법에서 {}는 메타 기호로 0번 이상 반복을 표현하지만, 
      BNF 표기법에서는 {}가 메타 기호에 해당하지 않고 단순 단말 기호로만 해석 된다.
  
  08. <unsigned integer> 정의의 다른 표현으로 바른 것은 ?
    1) <unsigned integer> ::= [ <digit> ] <digit>
    2) <unsigned integer> ::= <digit> | <digit><digit>
    3) <unsigned integer> ::= <unsigned integer><digit> | <digit>
    4) <unsigned integer> ::= <digit> | <unsigned integer>
      1과 2는 한 자리 혹은 두 자리 수만 표현되고, 4는 한 자리 수만 표현 된다. 3은 한 자리 이상의 수를 모두 표현 할 ㅅ ㅜ있다.
  
  09. 
  
  10. 의미론을 표현하는 방법이 아닌 것은 ?
    1) 문맥 자유 문법
    2) 기능적 의미론
    3) 표기적 의미론
    4) 공리적 의미론
      문맥 자유 문법은 구문을 표현하는 방법이다. 의미론을 표현하는 방법에는 속성 문법, 기능적 의미론, 표기적 의미론, 공리적 의미론 등이 있다.
```

```
  01. 프로그래밍 언어 정의와 가장 관련이 적은 것은 ?
    1) 기능적 의미론
    2) 문맥자유 문법
    3) 자연어
    4) 추상 구문 트리
      추상 구문 트리는 언어 번역시 생성되는 자료 구조이다.
      
  03. 객체지향 언어에도 전통적인 언어의 프로ㅓ시저에 해당하는 것이 존재한다. 다음 중 객체지향 언어에서 전통적인 프로그래밍 언어의 프로시저와 가장 까까운 것은 ?
    1) 메소드
    2) 변수
    3) 인터페이스
    4) 클래스
      메소드는 객체에 소속 된 서브프로그램이므로 프로시저와 유사하다.
  
  04. 다음 중 객체지향 언어의 자료형 상속과 가장 관련이 적은 것은 ?
    1) IS-A 관례
    2) 가상함수 테이블(V-Tab)
    3) 부분형
    4) 템플릿
      템플릿은 매개변수를 이용하여 다형성을 지원하는 방식으로서, 상속과 가장 거리가 멀다.
  
  05. 언어 패러다임이 실제 기계와 차이가 클 경우 추상기계 혹은 가상기계를 사용한다. 다음 중 가상기계로 얻을 수 있는 이점으로 가장 적합한 것은 ?
    1) FIFO
    2) GIGO
    3) WYSIWYG
    4) WORA
      가상기계를 이용하면 한 번 작성 된 코드를 가상기계가 탑재된 어디에서나 수행시킬 수 있다. WORA는 javaa의 슬로건이기도 하다.
  
  06. 다음 중 컴파일러의 전단부와 후단부를 구별하는 자료구조는 ?
    1) 구문 트리
    2) 심볼테이블
    3) 중간 표현
    4) 흐름 그래프
      컴파일러의 전단부와 후단부를 구별하는 자료 구조는 중간 표현(중간 코드)이다.
  
  07. 언어 구현 방법 중에는 컴파일러와 인터프리터를 혼합 한 형태의 구현 방법도 존재한다. 이러한 구현 방법을 지칭하는 용어는 ?
    1) 믹스인
    2) 프로토타이핑
    3) 하이브리드 구현
    4) 하향식 구현
      컴파일러와 인터프리터를 혼합 한 형태의 구현 방법을 하이브리드 구현이라고 부른다.
  
  08. 다음 중 구문 트리를 순회하는 여러 프로시저로 구성되는 구문 분석기로서 문법 구조와 프로그램 구조가 같은 형태인 하향식(top-down)구문 분석기는 ?
    1) LL 구문 분석기
    2) LR 구문 분석기
    3) 순환 하강 구문 분석기
    4) 연산자 우선 순위 구문 분석기
      보기 중에서 하향식 구문 분석기는 LL 구문 분석기와 순환 하강 구문 분석이인데,
      이 중에서 문법 구조와 프로그램 구조가 같은 형태는 순환 하강 구문 분석기 이다.
  
  09. 다음 중 추상 구문 트리의 특징으로 볼 수 없는 것은 ?
    1) 루트 하나로 구성 된 단일 루트 트리이다.
    2) 모든 문법 기호를 포함하는 트리이다.
    3) 파스 트리보다 축약 된 형태의 트리이ㅏㄷ.
    4) 단말 기호가 내부 노드로 존재 할 수 있다.
      추상 구문 트리는 축약 된 형태의 트리이므로 문법 기호 중 비단말 기호 대부분은 포함하지 않는다.
  
  10. 다음 중 일반적으로 언어 구현에 사용되는 자료 구조가 아닌 것은 ?
    1) 가상함수 테이블
    2) 뷰 테이블
    3) 심볼 테이블
    4) 해시 테이블
      뷰 테이블은 데이터베이스 질으 ㅣ처리에서 사용 되는 가상테이블로서 언어 구현과는 관련이 없다.
```

```
  01. 변수에 대한 설명으로 바르지 않은 것은 ?
    1) 변수는 데이터를 저장하거나 나중에 사용할 수 있도록 메모리를 추상화 한 것이다.
    2) 변수의 타입은 변수에 저장할 수 있는 데이터 집합의 종류를 의미한다.
    3) 변수의 주소는 변수가 사용하는 메모리의 위치를 나타낸다.
    4) 변수의 값은 수행시간 동안 바뀔 수 없다.
      변수의 값은 수행시간 동안 바뀔 수 있다.
  
  02. 변수의 네 가지 속성에 해당하지 않는 것은 ?
    1) 변수명
    2) 예약어
    3) 주소
    4) 값
      변수명, 타입, 주소, 값 이다.
  
  03. 배런의 표기법은 하나의 변수를 표현하는 방법으로,
      가장 왼쪽에 변수명
      가운데에 타입
      가장 오른쪽에 주소를 표기하고 주소 안에 값을 표기한다.
  
  04. 다음 변수를 배런의 표기법으로 바르게 나태는 것 
      int a := 2
    A . int . FFA0(2)
  
  05. 언어 구성 요소의 속성이 구체적으로 결정 되는 것을 의미하는 용어는
    1) 컴파일
    2) 스칼라
    3) 바인딩
    4) 인터프리트
      바인딩이란 언어 구성 요소의 속성이 구체적으로 결정 되는 것을 의미한다.
  
  06. 바인딩 시각의 종류와 거리가 먼 것은 ?
    1) 언어의 정의 시점
    2) 언어의 구현 시점
    3) 컴파일 시점
    4) 프로그램 수행 결과 분석 시점
      바인딩 시각은 바인딩이 일어나는 시점으로,
      언어의 정의시점,
      언어의 구현시점,
      컴파일 시점,
      링크 시점,
      로드 시점,
      프로그램 수행 시점으로 구분 할 수 있다.
  
  07. 바인딩 시각과 예시가 바르게 짝지어진 것은 ?
    1) 언어의 정의 시점 - 변수의 타입
    2) 언어의 구현 시점 - 수의 표기법                               - 정답
    3) 컴파일 시점 - 변수의 값
    4) 프로그램 수행 시점 - 정수의 자릿수
      변수의 타입은 컴파일 시점 혹은 프로그램 수행 시점에 바인딩 된다.
      변수의 값은 프로그램 수행 시점에 바인딩 된다.
      정수의 자릿수는 언어의 구현 시점에 바인딩 된다.
  
  08. 변수가 메모리를 할당받고 있는 기간을 의미하는 것은 ?
    1) 변수의 수명
    2) 변수의 블록 영역
    3) 변수의 속성
    4) 변수의 영역 구멍
      변수의 수명은 변수가 메모리를 할당 받고 이쓴ㄴ 기간으로 정의 된다.
  
  09. 변수의 종류와 사용하는 메모리가 잘못 짝지어진 것은 ?
    1) 정적 변수 - 정적 세그먼트
    2) 동적 변수 - 동적 세그먼트
    3) 스택 동적 변수 - 스택
    4) 힙 동적 변수 - 큐
      힙 동적 변수는 동적 세그먼트 중 힙에서 메모리를 할당 받는 변수이다.
  
  10. 다음 설명에 해당하는 변수는 ?
      - 동적 세그먼트에서 메모리를 할다
      - 수동 할당을 이용
    1) 정적 변수
    2) 스택 동적 변수
    3) 힙 동적 변수
    4) 큐 동적 변수
      동적 세그먼트에서 메모리를 할닫ㅇㅇ받는 변수에는
      스택 동적 변수와
      힙 동적 변수가 있다
      그 중 수동 할당을 이용하는 변수는 힙 동적 변수이다.
```

```
  01. 프로그램에서 변수를 사용할 수 있는 범위를 의미하는 것은 ?
    1) 할당
    2) 영역
    3) 수명
    4) 링크
      변수의 영역이란 프로그램에서 변수를 사용할 수 있는 범위로, 변수에 값을 대입하거나 변수의 값을 읽어올 수 있는 부분이다.
      변수의 수명은 변수가 메모리를 할당 받고 있는 기간으로, 병수의 영격보다 넓을 수 있기 때문에 수명은 있지만 사용할 수는 없는 부분이 있을 수 있다.
  
  02. 블록에 대한 설명으로 바르지 않은 것은 ?
    1) 영역을 구분해 주는 단위이다.
    2) 블록 안에서 변수를 선언할 수 있다.
    3) 선언 된 변수의 영역은 블록이 끝나는 곳까지 이다.
    4) 블록 안에서 선언 된 변수는 블록 밖에서 사용할 수 있다.
      블록 안에서 선언 된 변수의 영역은 블록이 끝나는 곳 까지이다.
  
  03. 다음 중 설명이 바르지 않은 것은 ?
    1) 영역 - 변수를 사용할 수 있는 프로그램 범위
    2) 지역변수 - 블록 밖에서 선언 된 변수
    3) 비지역 변수 - 블록 밖에서 선언 되었지만 블록 안에서 사용 될 수 있는 변수
    4) 자유 변수 - 현 블록에서 선언되지 않은 변수
      지역 변수는 블록 안에서 선언 된 변수이다.
  
  04. 특정 위치의 (   )은(는) 해당 위치의 모든 지역변수와 모든 비지역변수로 구성 된다.
    1) 활성화 레코드
    2) 참조 환경
    3) 활성화 코드부
    4) 활성화 상태
      참조 환 경은 한 위치에서 사용할 수 있는 모든 변수의 모음이다.
  
  05. 변수의 참조 위치를 결정 하는 방법을 의미하는 것은 ?
    1) 영역 규칙
    2) 할당 규칙
    3) 수명 규칙
    4) 환경 규칙
      영역 규칙은 변수의 참조 위치를 결정하는 방법으로, 특히 비지역변수의 위치를 결정하는 방법을 주로 다룬다.
  
  06. 자유 변수에 대한 설명으로 바른 것은 ?
    1) 현 블록에서 선언 된 변수
    2) 정적 영역 규칙에서는 현 블록을 내포하고 있는 가장 바깥 ?쪽으 ㅣ블록부터 조사
    3) 동적 영역 규칙에서는 프로그램의 실행 순서로 해결
    4) 선언을 찾지 못하면 0으로 초기화
      자유 변수는 현재 블록에서 선언 되지 않고 사용하려는 변수로,
      정적 영역 규칙에서는 현 블록을 내포하고 있는 가장 안쪽의 블록부터 조사하고
      동적 영역 규칙에서는 프로그램으 ㅣ실행 순서로 해결한다.
      선언을 찾지 못하면 오류로 판단한다.
  
  07. 변수의 영역이 정적 영역 규칙을 따르는 경우에 대한 설명으로 바른 거승ㄴ ?
    1) 컴파일 시점에 변수의 참조 위치 결정이 가능하다.
    2) 영역 구멍이 발생하지 않는다
    3) 변수의 영역이 실행기간에 결정된다.
    4) 자유 변수 문제는 프로그램의 실행 순서로 해결한다.
      정적 영역 규칙은 컴파일 시점에 변수의 참조 위치 결정이 가능하여 정적 타입 검사가 가능하고 동적 영역 규칙보다 수행 속도가 빠르다
      영역 구멍이 발생할 수 있고 
      변수의 영역이 컴파일 시간에 결정되고 
      자유 변수 문제는 정적 내포 관계로 해결한다.
  
  08. 비지역 변수가 같은 이름의 지역변수 때문에 보이지 않는 영역을 의미하는 용어는 ?
    1) 수명
    2) 영역구멍
    3) 속성
    4) 블록 영역
      영역 구멍은 비지역변수가 같은 이름의 지역변수 때문에 보이지 않는 영역을 의미한다.
  
  09. 변수의 영역이 동적 영역 규칙을 따르는 경우에 대한 설명으로 바른 것은 ?
    1) 블록들의 정적 내포 관계를 이용한다.
    2) 정적 타입 겁ㅁ사가 가능하다.
    3) 자유 변수 문제는 정적 부모를 따라가며 해결한다
    4) LISP등 인터프리터 방식의 언어에서 사용하는 경우가 많다.                            - 정답
      동적 영역 규칙은 수행 시점에 변수의 참조 위치 결정이 가능하여 정적 타입 검사가 불가능하다.
      정적 영역 규칙보다 수행속도가 느리고, 자유 변수 문제는 동적 내포 관계로 해결한다.
```

```
  01. 변수의 속성 중 한 가지로, 데이터 집합과 연산 집합의 결합으로 나타내는 것은 ?
    1) 변수명
    2) 타입
    3) 주소
    4) 값
      타입은 데이터를 효과적으로 처리하기 위한 개념으로 데이터 집합과 연산집합의 결합으로 나타낸다.
   
  02. 타입에 대한 설명으로 바르지 않은 것
    1) 데이터를 효과적으로 처리하기 위한 개념
    2) 데이터 집합과 연산 집합의 결합으로 나타낸다
    3) 서브프로ㅓ그램의 인자와 반환에도 이용 된다.
    4) 변수의 타입이 지정 되면 다른 타입의 데이터도 값으로 가질 수 있다.
  
  03. 타입 안전에 대한 설명으로 바른 것은
    1) 프로그램 내 일부 연산 및 함수에 대해 지정 된 입력 타입과 출력 타입이 지켜진다.
    2) 타입 안전해도 타입 오류가 발생할 수 있다.
    3) 프로그래밍 언어를 강타입 어너, 약타입언어, 무타입 언어로 구별한다.
    4) 입력 타입과 출력 타입이 서로 같아야 한다.
      프로그램 내 모든 연산 및 함수에 대해 지정 된 입력 타입고 ㅏ출력 타입이 지켜지면 그 프로그램은 타입 안전하다고 하며 이는 타입 오류가 발생하지 않는 다는 의미이다.
      프로그래밍 언어를 타입 안전성 측면에서 구별해보면 강, 약, 무타입 언어가 있다.
      입력과 출력 타입이 서로 같을 필요느 없다
  
  04. 다음 중 언어의 타입에 대한 설명으로 바르지 안흔것은 ?
    1) 강타입 언어는 프로그램에 존재하는 모든 타입 오류를 검출해 내는 언어이다.
    2) 약타입 언어는 일부 타입 오류를 허용하는 언어이다.
    3) 무타입 언어는 타입 개념이 없다
    4) 무타입 언어는 타입이 계속 바뀔 수 있느 ㄴ언어
      무타입 언어는 타입선언문이 없고 어떤 대상의 타입이 계속 바뀔 수 있는 언어로 타입 개념은 있다.
  
  05. 타입은 원시타입과 사용자정의 타입으로 분류할 수 있다. 다음 중 C의 ㅈ원시 타입에 해당하지 않는 것은 ?
    1) int
    2) char
    3) float
    4) enum                           - 정답
 
  06. 타입은 단순타입과 복합타입으로 분류할 수 있다. C++의 복합 타입에 해당하는 것은 ?
    1) int
    2) char
    3) enum
    4) class
      C++의 복합 타입에는 배열, class 등이 있다. enum은 단순타입이다.
  
  07. 정수형에 대한 설명으로 발느 것은 ?
    1) 정수형의 데이터 집합에는 모든 정수가 포함 된다.
    2) C에는 하나의 정수형만 존재한다.
    3) 정수형의 연산 집합에는 사칙연산만 포함 된다.
    4) C++ 는 정수형 데이터의 나눗셈은 결과도 정수형 데이터이다.                             - 정답
      정수형의 데이터 집합에는 사용 비트에 따라 일부 범위의 정수만 포함 되고
      C에는 short, int, long 등의 정수형이 존재한다.
      정수형의 연산 집합에는 사칙연산뿐만 아니라 나눗셈 연산 ,비트 연산 등도 포함 된다.
  
  08. 실수형에 대하ㅣㄴ 설명으로 바르지 않은 것은 ?
    1) 부동소수점 수는 가수부, 지수부ㅡ 부호의 세 부분으로 하나의 실수를 표기한다.
    2) C에서 float 타입은 부호에 1비트 ,지수부에 8비트, 가수부에 23비트를 사용한다.
    3) c에서 double 타입은 부호에 1비트, 지수부에 11비트 ,가수부에 52비트를 사용한다.
    4) 실수형 연산 집합에는 사칙연산뿐만 아니라 나눗셈 연산, 빈트 연산 등도 포함된다.                            - 정답
      나눗셈 연산과 비트 연산은 정수형 연산 집합에는 포함되지만 실수형 연산 집합에는 포함되지 않는다.
  
  09. 문자형에 대한 설명으로 바른 것은 ?
    1) 문자형은 여러 개의 문자 데이터를 다루는 타입이다.
    2) 문자형의 데이터 집합은 아스키코드 ㅈ문자만 포함 한다.
    3) java의 char타입은 16비트를 사용한다.
    4) c의 char 타입으 ㅣ연산 집합은 사칙연산은 포함하지만 비트 연산은 포함하지 않는다.
      문자형은 하나의 문자 데이터를 다루는 타입으로, 데이터 집합은 전통적으로 아스키코드 문자를 포함하지만 최근에는 유니코드 문자를 포함하기도 한다.
      c의 char 타입의 연산 집합은 사칙연산, 비트 연산 등을 포함 한다.
  
  10. 열거형에 대한 설명으로 바르지 않은 것은 ?
    1) 열거형은 순서 관계가 있는 이름들을 데이터로 다루는 타입이다.
    2) 열거형의 데이터 집합은 사용자가 직접 지정한 이름들을 포함한다.
    3) 열거형에서 다루는 각 이름은 모두 서로 다른 정수와 대응된다.                                         - 정답
    4) c와 c++는 열겨형은 enum타입이다.
      열거형이 다루는 각 이름은 0 이상의 정수와 대응되어 이름들 사이의 순서 관계를 정할 수 잇다.
      c와 c++는 이름뿐만 아니라 각 이름에 대응되는 정수도 직접 지정이 가능하여 서로 다른 이름이 같은 정수와 대응 될 ㅅ ㅜㅇ ㅣㅅ다.
```

```
  01. 원소를 첨자로 구별하는 동질형 자료의 집합체는 ?
    1) 배열
    2) 연상배열
    3) 구조체
    4) 포인터형
      배열은 동질형 데이터의 모음으로 구성 된 타입으로, 배열의 각 원소는 첨자로 구별한다.
  
  02. 배열에 대한 설명으로 바르지 않은 것은 ?
    1) 배열에 모여진 각 데이터를 원소라고 한다.
    2) 배열의 원소 타입은 사용자가 직접 지정할 수 없다.
    3) 배열이 가지는 원소의 개수를 배열의 크기라고 한다.
    4) 배열의 크기는 사용자가 직접 지정한다.
      배열의 원소 타입은 사용자가 직접 지정ㅎ나다.
  
  05. 키에 의해 접근 되는 순서를 갖지 않는 자료의 집합체는 ?
    1) 배열
    2) 구조체
    3) 포인터형
    4) 열관배열
      열관배열은 동질형 데이터의 순서 없는 모음으로 구성된 타입으로, 각 원소는 키로 구별한다.
  
  06. 원소를 이름으로 구별하는 이질형 자료의 집합체는 ?
    1) 배열
    2) 연상배열
    3) 구조체
    4) 포인터형
      구조체는 데이터의 모음으로 구성 된 타입으로 모여진 원소들의 타입은 서로 같아도 되고 달라도 되지만 각 원소는 이름으로 구별한다.
  
  07. 다음 중 올바른 설명은 무엇인가
    1) 배열은 이질형 자료의 집합체다.
    2) 구조체는 동질형 자료의 집합체다
    3) 배열은 이름으로 원소를 구별한다
    4) 배열과 레코드는 여러 자료를 묶어서 하나의 단위로 처리할 수 있다.
      배열은 동질형 자료의 집합체이고
      구조체는 이질형 자료의 집합체이고
      배열은 첨자로 원소를 구별하고
      구조체는 이름으로 원소를 구별한다
  
  08. 공용체에 대한 설명으로 바른 것은 ?
    1) 공용체는 저장 공간은 공유하는 데이터의 모음으로 구성된 타입이다.
    2) 공용체의 원소의 타입은 서로 같아야 한다.
    3) 공용체의 각 원소는 첨자로 구별한다
    4) 공용체에서 한 원소의 값이 바뀌어도 다른 원소들의 값은 영향을 받지 않는다.
      공용체의 원소의 타입은 같거나 다를 수 있고
      원소의 이름으로 구별한다.
      저장공간을 공유하기 때문에 한 원소의 값이 바뀌면 다른 원소들의 값도 영향을 받는다.
  
  09. 포인터형에 대한 설명으로 바르지 않은 것은 ?
    1) 특정 데이터가 저장되는 주소 자체를 데이터로 다루는 타입이다.
    2) 특정 데이터의 타입은 사용자가 지정할 수 있지만 단순타입만 가능하다.                                 - ㅈㄷ
    3) 데이터 집합에 포함되는 주소의 범위는 64비트 시스템에서 264을 넘지 않는다.
    4) 연산 집합은 대입 연ㅅ나, 덧셈 연산, 뺄셈 연산을 포함한다.
      포인터형은 특정 데이터가 저장되는 주소 자체를 데이터로 다루는 타입이다.
      특정 데이터의 타입은 사용자가 지정하는 타입으로 단순타입과 복합타입 모두 가능하다
      따라서 포인터형의 포인터형도 가능하다.
  
  10. 참조형을 이용하는 다음 C++ 프로그램에 대한 설명으로 잘못 된 것은 ?
      int k = 0;
      int &ref = k;
      ref = 10;
    1) ref는 int 타입의 데이터가 저장 된 k의 주소 자체를 자신의 주소로 사용한다.
    2) ref는 k가 아닌 다른 변수를 참조하도록 변경 될 수 엇ㅂ다.
    3) ref와 k는 서로 간에 별명(alias)이다.
    4) 세 번쨰 묹낭이 수행 된 후에도 k는 여전히 0이다.
      참조형 변수 ref는 변수 k와 동일한 주소를 사용하므로 세 번째 문장이 수행되면 k의 값도 10으로 바뀌게 된다.
```

```
  01. 수식에 대한 설명으로 바르지 않은 것은 ?
    1) 수식은 값을 나타내느 표현이다.
    2) 피연산자와 연ㅅ나자로 구성된다.
    3) -5.3, 2+3은 모두 수식의 예이다
    4) "abc", "R" + "&D"는 모두 수식이 아니다
      수식은 값을 나타내는 표현으로, 값에는 정수, 실수 데이터뿐만 아니라 문자열 데이터도 무두 해당한다.
      
  02. 수식은 (  ㄱ  )을(를) 나타내는 표현이며 문장은 (  ㄴ  )을 나타내는 표현이다.
    1) 값 처리
    2) 값 구문
    3) 처리 값
    4) 구문 값
      수식은 값을 나타내는 표현이며, 문장은 처리를 나타내는 표현이다.
  
  03. 다음 중 기본 연산자와 거리가 먼 것은 ?
    1) 산술 연산자
    2) 논리 연산자
    3) 번역 연산자
    4) 관계 연산자
      대부분의 프로그래밍 언어에서 제공하는 기본 연산자에는 산술 연산자, 관계 연산자, 논리 연산자 등이 포함 된다.
      연산자에는 함수도 포함되므로 번역 연산자도 있을 수 있지만 기본 연산자와는 거리가 멀다.
  
  04. 산술 연산자에 대한 설명으로 바른 것은 ?
    1) 덧셈, 뺄셈, 곳셈, 나눗셈의 사칙연산자가 포함된다.
    2) 덧셈 연산자의 피연산자는 1개이다.
    3) 곱셈 연산자의 피연산자는 3개이다.
    4) 뺄셈은 나눗셈보다 우선순위가 높다.
      덧셈과 곱셈 연산자의 피연산자는 2개다.
      뺄셈은 나눗셈보다 우선순위가 낮다.
  
  05. 다음 중 c의 산술 연산자와 분류가 잘못 짝지어진 것은 ?
    1) - : 이항 연산자
    2) / : 이항 연산자
    3) ++: 단항 연산자
    4) >>: 단항 연산자
      >>은 이항 연산자로, 왼쪽 피연산자를 오른쪽 피연산자만큼 오른쪽으로 비트 단위 시프트하는 연산자이다.
  
  06. 다음 중 c의 산술 연산자 중 우선순위가 가장 높은 연산자는 ?
    1) --(전위)
    2) *
    3) +
    4) <<
      우선 순위가 높은 순은 --, *, +, << 이다.
  
  07. 다음 중 묵시적 타입 변환에 대한 설명으로 바른 것은 ?
    1) 캐스트 명령어 사용
    2) 컴파일러에서 자동 수행
    3) 명령문으로 요구한 타입으로 변환
    4) 프로그래머가 명시
      묵시적 타입 변환은 프로그래밍 언어의 정책에 따라 컴파일러에 의해 자동으로 변환 되는 방법이다.
  
  08. 타입 변환에 대한 설명으로 바른 것은 ?
    1) 주어진 타입의 값을 다른 타입의 값으로 변환하는 것이다.
    2) 묵시적 타입 변환은 캐스트 명령어를 사용한다.
    3) 실수형 변수 A, B에 대해 A+B를 계산할 때 발생한다.
    4) 명시적 타입 변환은 프로그래머가 명시할 필요가 없다.
      묵시적 타입 변환은 캐스트 명령어를 사용할 필요가 없고
      명시적 타입 변환은 프로그래머가 명시한 타입으로 변환 되므로 명시할 필요가 있다.
      두 실수형 변수으 ㅣ갑승ㄹ 더할때는 실수 덧셈 연산을 이용하면 되므로 변환이 발생하지 않는다.
  
  09. 연산자 우선 순위에 맞춰 다음 수식에 괄호를 바르게 붙인 것은 ?
      5 * 2 >= 3 -1
    ((5*2) >= (3=1))
      우선 순위는 *, -, >= 이다.
  
  10.
    
```

```
  01. 문장에 대한 설명으로 바르지 않은 것은 ?
    1) 문장은 처리를 나타내는 표현이다.
    2) 문장은 데이터 처리를 위해 변수, 연산, 서브프로그램을 이용한다.
    3) 문장으 ㅣ처리 후 하나의 값을 나타낸다.                         - 정답
    4) 문장은 선언문과 실행문으로 구분 된다.
      수식은 계산 후 하나의 값으 ㄹ나타내지만 문장은 처리만 한다.
  
  02. 선언문에 대한 설명으로 바른 것은 ?
    1) 변수를 이용 할 수 있도록 변수명과 타입 등을 바인딩한다.
    2) 변수에 값을 대입한 후 해당 변수의 선언문을 둔다.
    3) 서브프로그램 선언문이 존재하지 않는다.
    4) 서브프로그램 선언문은 서브프로그램이 수행할 일을 명시한다.
      선언문은 변수나 서브프로그램을 이용할 수 있도록 준비를 해준다.
      변수 선언문이 먼저 나온 후 해당 변수에 값을 대입할 수 있다.
      서브프로그램 선언문은 서브프로그램의 프로토콜을 명시한다.
      수행할 일을 명시하는 것은 서브프로그램으 ㅣ정의이다. 
      
  03. 실행문에 해당하지 않는 것은 ?
    1) 대입문
    2) 조건문
    3) 반복문
    4) 선언문
      실행문에는 대입문과 제어문이 있고, 제어문은 다시 조건문과 반복문으로 구성된다.
      선언문은 실행문에서 사용 될 변수나 서브프로그램을 준비하는 역할을 한다.
  
  04. 프로그램에서 가장 자주 사용되는 문장으로 변수의 값을 바꾸는 문장은 ?
    1) 조건문
    2) 반복문
    3) 제어문
    4) 대입문
      대입문은 프로그램에서 가장 자주 사용되는 문장으로 변수의 값을 벼ㅛㄴ경
  
  05. 다음중 c의 대입문에 해당하는 것은 ?
    1) A == B;
    2) A >= B;
    3) A > B : C;
    4) A++;
      ++는 피연산자가 가진 값에 1을 더한 값으 ㄹ대입하는 대입 연산자이다.
 
  06. 다음 중 C의 대입문에 해당하지 않는 것은 ?
    1) A /= B;
    2) A *= B;
    3) A != B;
    4) A ++;
      /=, *= 복합 대입 연산자이고, ++는 단항 대입 연산자이다. !=는 관계 연산자이다.
  
  07. java에서 다음과 같이 선언 된 변수들을 이용할 때 오류가 발생하는 대입문은 ?
      int n=1, m=2;
      double p=3.0, q=4.0;
      int a, b;
      double c,d;
    1) a= n + m;
    2) b= p + q;
    3) c= n + m;
    4) d= p + q;
      자바는 묵시적인 축소변환을 지원하지 않으므로 int타입에 double 타입의 값을 대입하는 2번에서 오류가 발생함.
  
  08. 제어문과 예가 올바르게 짝지어진 것은 ?
    1) 조건문: for (i=0; i<3; i++) a =3;
    2) 반복문: while (true) a = 3;
    3) 대입문: a = 3;
    4) 반복문: switch(i) { case 1: a = 3; }
      1은 반복문
      4는 조건문
      3의 대입문은 제어문에 해당하지 않는다.
  
  09. 프로그램에서 조건에 따라 실행 되는 부ㅜ분이 다를 때 사용 하는 문장은 ?
    2) 조건문
  
  10. 반복할 문장이 어떤 경우에도 최소한 한 번은 수행 되는 ㅁ반복문은 ?
    1) switch
    2) for
    3) while
    4) do-while
      do-while은 필요한 문장 다음에 조건이 오므로 필요한 문장을 최소한 한 번은 수행하게 된다.

```

```
  01. 서브프로그램과 가장 관려ㅛㄴ이 적은 것은 ?
    1) 단락 회로 계산
    2) 매개 변수
    3) 시그니처 매칭
    4) 프로토 타입
      단락회로 계산은 서브프로그램보다는 연산자의 의미와 관련이 깊다.
  
  02. 다음 중 서브프로그램의 입출력과 가장 관련이 적은 것은 ?
    1) 매개변수
    2) 반환값
    3) 인수
    4) 콘솔
      콘솔은 표준 입출력과 관련이 있지만 서브프로그램 입장에서는 부수효과로 간주한다.
  
  03. c++ 언어의 기능 중에서 이름에 의하 ㄴ 인수 전달과 갖아 유사한 것은 
    1) 구조체 전달
    2) 매크로 인수 전달
    3) 배열 전달
    4) 참조 전달
      이름 전달은 이름을 그대로 치환하는 방식이므로 매크로 인수 전달과 가장 유사하다.
      
  04. 다음 중 인수 전달 방법으로 참조 전달을 지원하지 않는 언어는 ?
    1) Fortran
    2) C
    3) Pascal
    4) Python
      c는 값 전달만 지우너한다.
  
  05. 다음 중 서브프로그램의 일반적인 특징으로 적합하지 않은 것은 ?
    1) 여러 입구가 존재
    2) 여러 출구가 존재
    3) 서브프로그램의 맨 끝은 자동적으로 출구가 된다
    4) 서브프로그램의 호출 및 반환에 따라 제어 흐름이 바뀐다.
      서브프로그램의 출그는 여러 곳이 될 수 있지만 입구는 통상 하나이다.
  
  06. 다음 중 매개변수 프로파일에는 포함되지 않지만 서브프로그램 프로토콜에는 포함 되는 것은 ?
    1) 매개변수 개수
    2) 매개변수의 순서
    3) 매개변수의 타입
    4) 반환 타입
    
  07. 다음 중 출력 모드의 매개변수를 지원 할 수 없는 인수 전달 방법은 ?
    1) 값 전달
    2) 값-결과 전달
    3) 참조 전달
    4) 이름 전달
      값 전달은 출력 모드의 매개변수를 지원할 수 없다.
```


